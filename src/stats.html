<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI API ÏÇ¨Ïö©Îüâ ÎåÄÏãúÎ≥¥Îìú (IndexedDB)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .data-source {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            text-align: center;
        }

        .source-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .source-status {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .source-status.connected {
            background: rgba(34, 197, 94, 0.1);
            color: #16a34a;
        }

        .source-status.disconnected {
            background: rgba(239, 68, 68, 0.1);
            color: #dc2626;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-weight: 600;
            color: #555;
            font-size: 0.9rem;
        }

        select, button {
            padding: 10px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .summary-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            text-align: center;
            transition: transform 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .summary-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #667eea, #764ba2);
        }

        .summary-card:hover {
            transform: translateY(-5px);
        }

        .card-icon {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .card-value {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .card-title {
            color: #666;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .charts-section {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .chart-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .details-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .detail-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .logs-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .logs-table th {
            background: var(--bg-secondary, #f8f9fa);
            padding: 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #e9ecef;
        }

        .logs-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #e9ecef;
        }

        .logs-table tr:hover {
            background: rgba(102, 126, 234, 0.05);
        }

        .feature-list {
            list-style: none;
        }

        .feature-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .feature-item:last-child {
            border-bottom: none;
        }

        .item-name {
            font-weight: 500;
        }

        .item-stats {
            text-align: right;
            font-size: 0.9rem;
            color: #666;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-success {
            background: #22c55e;
        }

        .status-error {
            background: #ef4444;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: white;
            font-size: 1.2rem;
        }

        .error {
            background: rgba(239, 68, 68, 0.1);
            color: #dc2626;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            border-left: 4px solid #ef4444;
        }

        .export-section {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            text-align: center;
        }

        .export-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
        }

        .export-btn {
            padding: 12px 25px;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s ease;
        }

        .export-btn:hover {
            transform: translateY(-2px);
        }

        @media (max-width: 768px) {
            .charts-section {
                grid-template-columns: 1fr;
            }
            
            .details-section {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }

        .no-data {
            text-align: center;
            padding: 50px;
            color: #999;
            font-size: 1.2rem;
        }

        .refresh-info {
            font-size: 0.9rem;
            color: #666;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üóÑÔ∏è AI API ÏÇ¨Ïö©Îüâ ÎåÄÏãúÎ≥¥Îìú</h1>
            <p>IndexedDB Í∏∞Î∞ò Î°úÏª¨ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù</p>
        </div>

        <!-- Îç∞Ïù¥ÌÑ∞ ÏÜåÏä§ ÏÉÅÌÉú -->
        <div class="data-source">
            <div class="source-info">
                <span>üìä Îç∞Ïù¥ÌÑ∞ ÏÜåÏä§: IndexedDB</span>
                <span id="connectionStatus" class="source-status disconnected">Ïó∞Í≤∞ ÌôïÏù∏ Ï§ë...</span>
            </div>
            <div class="refresh-info">
                <span id="lastUpdate">ÎßàÏßÄÎßâ ÏóÖÎç∞Ïù¥Ìä∏: ÌôïÏù∏ Ï§ë...</span>
                <button onclick="loadIndexedDBData()" style="margin-left: 15px;">üîÑ ÏÉàÎ°úÍ≥†Ïπ®</button>
            </div>
        </div>

        <!-- Ïª®Ìä∏Î°§ Ìå®ÎÑê -->
        <div class="controls" id="controls" style="display: none;">
            <div class="control-group">
                <label>Í∏∞Í∞Ñ Ïú†Ìòï</label>
                <select id="periodType" onchange="updateData()">
                    <option value="daily">ÏùºÎ≥Ñ</option>
                    <option value="weekly">Ï£ºÍ∞ÑÎ≥Ñ</option>
                    <option value="monthly">ÏõîÍ∞ÑÎ≥Ñ</option>
                </select>
            </div>
            <div class="control-group">
                <label>Î≤îÏúÑ</label>
                <select id="rangeSelect" onchange="updateData()">
                    <option value="7">ÏµúÍ∑º 7Ïùº</option>
                    <option value="14">ÏµúÍ∑º 14Ïùº</option>
                    <option value="30">ÏµúÍ∑º 30Ïùº</option>
                </select>
            </div>
            <div class="control-group">
                <label>Ï†úÍ≥µÏóÖÏ≤¥</label>
                <select id="providerFilter" onchange="updateData()">
                    <option value="">Ï†ÑÏ≤¥</option>
                </select>
            </div>
            <button onclick="exportData()">üì§ CSV ÎÇ¥Î≥¥ÎÇ¥Í∏∞</button>
        </div>

        <div id="loadingIndicator" class="loading">
            üìä IndexedDBÏóêÏÑú Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ë...
        </div>

        <div id="errorContainer"></div>

        <div id="dashboardContent" style="display: none;">
            <!-- ÏöîÏïΩ Ïπ¥Îìú -->
            <div class="summary-cards">
                <div class="summary-card">
                    <div class="card-icon">üîÑ</div>
                    <div class="card-value" id="totalCalls">0</div>
                    <div class="card-title">Ï¥ù Ìò∏Ï∂ú Ïàò</div>
                </div>
                <div class="summary-card">
                    <div class="card-icon">üéØ</div>
                    <div class="card-value" id="totalTokens">0</div>
                    <div class="card-title">Ï¥ù ÌÜ†ÌÅ∞ Ïàò</div>
                </div>
                <div class="summary-card">
                    <div class="card-icon">üí∞</div>
                    <div class="card-value" id="totalCost">$0.00</div>
                    <div class="card-title">Ï¥ù ÎπÑÏö©</div>
                </div>
                <div class="summary-card">
                    <div class="card-icon">‚ö°</div>
                    <div class="card-value" id="avgLatency">0ms</div>
                    <div class="card-title">ÌèâÍ∑† ÏßÄÏó∞ÏãúÍ∞Ñ</div>
                </div>
                <div class="summary-card">
                    <div class="card-icon">‚úÖ</div>
                    <div class="card-value" id="successRate">100%</div>
                    <div class="card-title">ÏÑ±Í≥µÎ•†</div>
                </div>
            </div>

            <!-- Ï∞®Ìä∏ ÏÑπÏÖò -->
            <div class="charts-section">
                <div class="chart-container">
                    <div class="chart-title">üìà ÏÇ¨Ïö©Îüâ Ìä∏Î†åÎìú</div>
                    <canvas id="trendChart"></canvas>
                </div>
                <div class="chart-container">
                    <div class="chart-title">üè¢ Ï†úÍ≥µÏóÖÏ≤¥Î≥Ñ Î∂ÑÌè¨</div>
                    <canvas id="providerChart"></canvas>
                </div>
            </div>

            <!-- ÏÉÅÏÑ∏ Ï†ïÎ≥¥ ÏÑπÏÖò -->
            <div class="details-section">
                <div class="detail-card">
                    <div class="chart-title">üéØ Í∏∞Îä•Î≥Ñ ÏÇ¨Ïö©Îüâ</div>
                    <ul class="feature-list" id="featureList"></ul>
                </div>
                <div class="detail-card">
                    <div class="chart-title">üí∞ ÎπÑÏö© Î∂ÑÏÑù</div>
                    <canvas id="costChart"></canvas>
                </div>
            </div>

            <!-- ÏµúÍ∑º Î°úÍ∑∏ ÌÖåÏù¥Î∏î -->
            <div class="detail-card">
                <div class="chart-title">üìù ÏµúÍ∑º API Ìò∏Ï∂ú Î°úÍ∑∏</div>
                <table class="logs-table" id="logsTable">
                    <thead>
                        <tr>
                            <th>ÏãúÍ∞Ñ</th>
                            <th>Ï†úÍ≥µÏóÖÏ≤¥</th>
                            <th>Î™®Îç∏</th>
                            <th>Í∏∞Îä•</th>
                            <th>ÌÜ†ÌÅ∞</th>
                            <th>ÎπÑÏö©</th>
                            <th>ÏßÄÏó∞ÏãúÍ∞Ñ</th>
                            <th>ÏÉÅÌÉú</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>

            <!-- ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ÏÑπÏÖò -->
            <div class="export-section">
                <div class="chart-title">üì§ Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞</div>
                <div class="export-buttons">
                    <button class="export-btn" onclick="exportToCSV()">üìä CSV Îã§Ïö¥Î°úÎìú</button>
                    <button class="export-btn" onclick="exportToJSON()">üìã JSON Îã§Ïö¥Î°úÎìú</button>
                    <button class="export-btn" onclick="clearIndexedDB()">üóëÔ∏è Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // IndexedDB Í¥ÄÎ¶¨ ÌÅ¥ÎûòÏä§
        class IndexedDBManager {
            constructor() {
                this.dbName = 'ai-api-logs.db';
                this.dbVersion = 1;
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };
                    
                    request.onupgradeneeded = () => {
                        // ÎåÄÏãúÎ≥¥ÎìúÏóêÏÑúÎäî ÏùΩÍ∏∞Îßå ÌïòÎØÄÎ°ú Ïä§ÌÇ§Îßà ÏÉùÏÑ± Î∂àÌïÑÏöî
                        reject(new Error('IndexedDB Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Í∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§. Obsidian ÌîåÎü¨Í∑∏Ïù∏ÏùÑ Î®ºÏ†Ä Ïã§ÌñâÌïòÏÑ∏Ïöî.'));
                    };
                });
            }

            async getAllLogs() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['api_logs'], 'readonly');
                    const store = transaction.objectStore('api_logs');
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async getDailyStats(days = 30) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['daily_stats'], 'readonly');
                    const store = transaction.objectStore('daily_stats');
                    const index = store.index('date');
                    
                    const endDate = new Date();
                    const startDate = new Date(endDate);
                    startDate.setDate(startDate.getDate() - days);
                    
                    const range = IDBKeyRange.bound(
                        startDate.toISOString().split('T')[0],
                        endDate.toISOString().split('T')[0]
                    );
                    
                    const request = index.getAll(range);
                    
                    request.onsuccess = () => {
                        const stats = request.result;
                        const processedStats = this.processDailyStats(stats, days);
                        resolve(processedStats);
                    };
                    
                    request.onerror = () => reject(request.error);
                });
            }

            processDailyStats(stats, days) {
                // ÏùºÎ≥ÑÎ°ú Í∑∏Î£πÌôî
                const dailyData = {};
                
                // Îπà ÎÇ†ÏßúÎì§ÎèÑ Ï¥àÍ∏∞Ìôî
                for (let i = 0; i < days; i++) {
                    const date = new Date();
                    date.setDate(date.getDate() - i);
                    const dateStr = date.toISOString().split('T')[0];
                    dailyData[dateStr] = {
                        period: this.formatDate(date),
                        totalCalls: 0,
                        totalTokens: 0,
                        totalCost: 0,
                        avgLatency: 0,
                        successRate: 100,
                        providers: {},
                        features: {}
                    };
                }
                
                // Ïã§Ï†ú ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
                stats.forEach(stat => {
                    if (!dailyData[stat.date]) {
                        dailyData[stat.date] = {
                            period: this.formatDate(new Date(stat.date)),
                            totalCalls: 0,
                            totalTokens: 0,
                            totalCost: 0,
                            avgLatency: 0,
                            successRate: 0,
                            providers: {},
                            features: {}
                        };
                    }
                    
                    const day = dailyData[stat.date];
                    day.totalCalls += stat.totalCalls;
                    day.totalTokens += stat.totalTokens;
                    day.totalCost += stat.totalCost;
                    day.avgLatency = stat.avgLatency; // Ïù¥ÎØ∏ ÌèâÍ∑†Í∞í
                    day.successRate = stat.successRate; // Ïù¥ÎØ∏ Î∞±Î∂ÑÏú®
                    day.providers[stat.provider] = (day.providers[stat.provider] || 0) + stat.totalCalls;
                    
                    // Í∏∞Îä•Î≥Ñ ÏßëÍ≥Ñ
                    Object.entries(stat.features || {}).forEach(([feature, calls]) => {
                        day.features[feature] = (day.features[feature] || 0) + calls;
                    });
                });
                
                // ÏµúÏ¢Ö Ï†ïÎ¶¨
                return Object.values(dailyData).map(day => ({
                    ...day,
                    topFeatures: Object.entries(day.features)
                        .map(([feature, calls]) => ({ feature, calls, cost: 0 }))
                        .sort((a, b) => b.calls - a.calls)
                        .slice(0, 5),
                    providerBreakdown: Object.entries(day.providers)
                        .map(([provider, calls]) => ({
                            provider,
                            calls,
                            percentage: day.totalCalls > 0 ? (calls / day.totalCalls) * 100 : 0
                        }))
                        .sort((a, b) => b.calls - a.calls)
                })).sort((a, b) => a.period.localeCompare(b.period));
            }

            formatDate(date) {
                return `${date.getMonth() + 1}/${date.getDate()}`;
            }

            async clearAllData() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['api_logs', 'daily_stats'], 'readwrite');
                    
                    const logsStore = transaction.objectStore('api_logs');
                    const statsStore = transaction.objectStore('daily_stats');
                    
                    const clearLogs = logsStore.clear();
                    const clearStats = statsStore.clear();
                    
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = () => reject(transaction.error);
                });
            }
        }

        // Ï†ÑÏó≠ Î≥ÄÏàò
        let dbManager = null;
        let currentData = [];
        let allLogs = [];
        let charts = {};

        // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú Ï¥àÍ∏∞Ìôî
        document.addEventListener('DOMContentLoaded', function() {
            initializeDashboard();
        });

        async function initializeDashboard() {
            try {
                dbManager = new IndexedDBManager();
                await dbManager.init();
                
                document.getElementById('connectionStatus').textContent = 'Ïó∞Í≤∞Îê®';
                document.getElementById('connectionStatus').className = 'source-status connected';
                
                await loadIndexedDBData();
            } catch (error) {
                console.error('IndexedDB Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error);
                showError('IndexedDB Ïó∞Í≤∞ Ïã§Ìå®: ' + error.message + '\n\nObsidian ÌîåÎü¨Í∑∏Ïù∏ÏùÑ Î®ºÏ†Ä Ïã§ÌñâÌïòÍ≥† AI APIÎ•º ÏÇ¨Ïö©Ìï¥Î≥¥ÏÑ∏Ïöî.');
                
                document.getElementById('connectionStatus').textContent = 'Ïó∞Í≤∞ Ïã§Ìå®';
                document.getElementById('connectionStatus').className = 'source-status disconnected';
            }
        }

        async function loadIndexedDBData() {
            if (!dbManager) {
                showError('IndexedDBÍ∞Ä Ï¥àÍ∏∞ÌôîÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
                return;
            }

            showLoading();
            hideError();

            try {
                // Î™®Îì† Î°úÍ∑∏ Í∞ÄÏ†∏Ïò§Í∏∞
                allLogs = await dbManager.getAllLogs();
                
                if (allLogs.length === 0) {
                    hideLoading();
                    showError('Ï†ÄÏû•Îêú API Î°úÍ∑∏Í∞Ä ÏóÜÏäµÎãàÎã§.\n\nObsidianÏóêÏÑú AI Í∏∞Îä•ÏùÑ ÏÇ¨Ïö©ÌïòÎ©¥ Î°úÍ∑∏Í∞Ä Ïó¨Í∏∞Ïóê ÌëúÏãúÎê©ÎãàÎã§.');
                    return;
                }

                // UI ÏóÖÎç∞Ïù¥Ìä∏
                hideLoading();
                document.getElementById('controls').style.display = 'flex';
                document.getElementById('dashboardContent').style.display = 'block';
                
                // Ï†úÍ≥µÏóÖÏ≤¥ ÌïÑÌÑ∞ ÏòµÏÖò ÏóÖÎç∞Ïù¥Ìä∏
                updateProviderFilter();
                
                // Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Î∞è ÌëúÏãú
                await updateData();
                
                // ÏµúÍ∑º Î°úÍ∑∏ ÌÖåÏù¥Î∏î ÏóÖÎç∞Ïù¥Ìä∏
                updateLogsTable(allLogs.slice(-50).reverse()); // ÏµúÍ∑º 50Í∞ú
                
                document.getElementById('lastUpdate').textContent = 
                    `ÎßàÏßÄÎßâ ÏóÖÎç∞Ïù¥Ìä∏: ${new Date().toLocaleString()} (${allLogs.length}Í∞ú Î°úÍ∑∏)`;

            } catch (error) {
                hideLoading();
                showError('Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®: ' + error.message);
                console.error('Error loading IndexedDB data:', error);
            }
        }

        function updateProviderFilter() {
            const providers = [...new Set(allLogs.map(log => log.provider))];
            const select = document.getElementById('providerFilter');
            
            // Í∏∞Ï°¥ ÏòµÏÖò Ï†úÍ±∞ (Ï≤´ Î≤àÏß∏ "Ï†ÑÏ≤¥" ÏòµÏÖò Ï†úÏô∏)
            while (select.children.length > 1) {
                select.removeChild(select.lastChild);
            }
            
            providers.forEach(provider => {
                const option = document.createElement('option');
                option.value = provider;
                option.textContent = provider.toUpperCase();
                select.appendChild(option);
            });
        }

        async function updateData() {
            const periodType = document.getElementById('periodType').value;
            const range = parseInt(document.getElementById('rangeSelect').value);
            const providerFilter = document.getElementById('providerFilter').value;

            try {
                let stats;
                if (periodType === 'daily') {
                    stats = await dbManager.getDailyStats(range);
                } else {
                    // Ï£ºÍ∞Ñ/ÏõîÍ∞ÑÏùÄ Î°úÍ∑∏ÏóêÏÑú ÏßÅÏ†ë Í≥ÑÏÇ∞
                    stats = calculateStatsFromLogs(allLogs, periodType, range);
                }

                // Ï†úÍ≥µÏóÖÏ≤¥ ÌïÑÌÑ∞ Ï†ÅÏö©
                if (providerFilter) {
                    stats = stats.map(stat => ({
                        ...stat,
                        // ÌïÑÌÑ∞Îêú Ï†úÍ≥µÏóÖÏ≤¥Îßå ÌëúÏãúÌïòÎèÑÎ°ù Ï°∞Ï†ï
                        providerBreakdown: stat.providerBreakdown.filter(p => p.provider === providerFilter)
                    }));
                }

                currentData = stats;
                
                updateSummaryCards(stats);
                updateCharts(stats);
                updateFeatureList(stats);

            } catch (error) {
                console.error('Error updating data:', error);
                showError('Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®: ' + error.message);
            }
        }

        function calculateStatsFromLogs(logs, periodType, range) {
            const now = new Date();
            const startDate = new Date(now);
            
            if (periodType === 'weekly') {
                startDate.setDate(startDate.getDate() - (range * 7));
            } else if (periodType === 'monthly') {
                startDate.setMonth(startDate.getMonth() - range);
            }

            // ÌïÑÌÑ∞ÎßÅ
            const filteredLogs = logs.filter(log => {
                const logDate = new Date(log.timestamp);
                return logDate >= startDate;
            });

            // Í∏∞Í∞ÑÎ≥Ñ Í∑∏Î£πÌôî
            const grouped = {};
            
            filteredLogs.forEach(log => {
                const date = new Date(log.timestamp);
                let key;

                if (periodType === 'weekly') {
                    const weekStart = new Date(date);
                    weekStart.setDate(date.getDate() - date.getDay());
                    key = weekStart.toISOString().split('T')[0];
                } else if (periodType === 'monthly') {
                    key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                }

                if (!grouped[key]) {
                    grouped[key] = {
                        period: formatPeriod(key, periodType),
                        totalCalls: 0,
                        totalTokens: 0,
                        totalCost: 0,
                        latencySum: 0,
                        successCount: 0,
                        features: {},
                        providers: {}
                    };
                }

                const group = grouped[key];
                group.totalCalls++;
                group.totalTokens += log.totalTokens || 0;
                group.totalCost += log.cost || 0;
                group.latencySum += log.latency || 0;
                if (log.success) group.successCount++;

                // Í∏∞Îä•Î≥Ñ ÏßëÍ≥Ñ
                if (!group.features[log.feature]) {
                    group.features[log.feature] = { calls: 0, cost: 0 };
                }
                group.features[log.feature].calls++;
                group.features[log.feature].cost += log.cost || 0;

                // Ï†úÍ≥µÏóÖÏ≤¥Î≥Ñ ÏßëÍ≥Ñ
                group.providers[log.provider] = (group.providers[log.provider] || 0) + 1;
            });

            // ÏµúÏ¢Ö Ï≤òÎ¶¨
            return Object.values(grouped).map(group => ({
                period: group.period,
                totalCalls: group.totalCalls,
                totalTokens: group.totalTokens,
                totalCost: group.totalCost,
                avgLatency: group.totalCalls > 0 ? group.latencySum / group.totalCalls : 0,
                successRate: group.totalCalls > 0 ? (group.successCount / group.totalCalls) * 100 : 100,
                topFeatures: Object.entries(group.features)
                    .map(([feature, data]) => ({ feature, calls: data.calls, cost: data.cost }))
                    .sort((a, b) => b.calls - a.calls)
                    .slice(0, 5),
                providerBreakdown: Object.entries(group.providers)
                    .map(([provider, calls]) => ({
                        provider,
                        calls,
                        percentage: group.totalCalls > 0 ? (calls / group.totalCalls) * 100 : 0
                    }))
                    .sort((a, b) => b.calls - a.calls)
            })).sort((a, b) => a.period.localeCompare(b.period));
        }

        function formatPeriod(key, periodType) {
            if (periodType === 'weekly') {
                const date = new Date(key);
                const endDate = new Date(date);
                endDate.setDate(endDate.getDate() + 6);
                return `${date.getMonth() + 1}/${date.getDate()} ~ ${endDate.getMonth() + 1}/${endDate.getDate()}`;
            } else if (periodType === 'monthly') {
                const [year, month] = key.split('-');
                return `${year}ÎÖÑ ${month}Ïõî`;
            }
        }

        function updateSummaryCards(stats) {
            const totals = stats.reduce((acc, stat) => ({
                totalCalls: acc.totalCalls + stat.totalCalls,
                totalTokens: acc.totalTokens + stat.totalTokens,
                totalCost: acc.totalCost + stat.totalCost,
                avgLatency: acc.avgLatency + stat.avgLatency,
                successRate: acc.successRate + stat.successRate
            }), { totalCalls: 0, totalTokens: 0, totalCost: 0, avgLatency: 0, successRate: 0 });

            document.getElementById('totalCalls').textContent = totals.totalCalls.toLocaleString();
            document.getElementById('totalTokens').textContent = totals.totalTokens.toLocaleString();
            document.getElementById('totalCost').textContent = `${totals.totalCost.toFixed(4)}`;
            document.getElementById('avgLatency').textContent = `${Math.round(totals.avgLatency / (stats.length || 1))}ms`;
            document.getElementById('successRate').textContent = `${(totals.successRate / (stats.length || 1)).toFixed(1)}%`;
        }

        function updateCharts(stats) {
            updateTrendChart(stats);
            updateProviderChart(stats);
            updateCostChart(stats);
        }

        function updateTrendChart(stats) {
            const ctx = document.getElementById('trendChart').getContext('2d');
            
            if (charts.trend) {
                charts.trend.destroy();
            }

            charts.trend = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: stats.map(stat => stat.period),
                    datasets: [
                        {
                            label: 'Ìò∏Ï∂ú Ïàò',
                            data: stats.map(stat => stat.totalCalls),
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y'
                        },
                        {
                            label: 'ÎπÑÏö© ($)',
                            data: stats.map(stat => stat.totalCost),
                            borderColor: '#fa709a',
                            backgroundColor: 'rgba(250, 112, 154, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Í∏∞Í∞Ñ'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Ìò∏Ï∂ú Ïàò'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'ÎπÑÏö© ($)'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                        }
                    }
                }
            });
        }

        function updateProviderChart(stats) {
            const ctx = document.getElementById('providerChart').getContext('2d');
            
            if (charts.provider) {
                charts.provider.destroy();
            }

            const providerTotals = {};
            stats.forEach(stat => {
                stat.providerBreakdown.forEach(provider => {
                    providerTotals[provider.provider] = (providerTotals[provider.provider] || 0) + provider.calls;
                });
            });

            const labels = Object.keys(providerTotals);
            const values = Object.values(providerTotals);
            const colors = ['#667eea', '#764ba2', '#4facfe', '#00f2fe', '#fa709a'];

            if (labels.length === 0) {
                // Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏùÑ Îïå
                charts.provider = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå'],
                        datasets: [{
                            data: [1],
                            backgroundColor: ['#e5e7eb']
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                display: false
                            }
                        }
                    }
                });
                return;
            }

            charts.provider = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels.map(label => label.toUpperCase()),
                    datasets: [{
                        data: values,
                        backgroundColor: colors.slice(0, labels.length),
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }

        function updateCostChart(stats) {
            const ctx = document.getElementById('costChart').getContext('2d');
            
            if (charts.cost) {
                charts.cost.destroy();
            }

            charts.cost = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: stats.map(stat => stat.period),
                    datasets: [{
                        label: 'ÎπÑÏö© ($)',
                        data: stats.map(stat => stat.totalCost),
                        backgroundColor: 'rgba(102, 126, 234, 0.8)',
                        borderColor: '#667eea',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'ÎπÑÏö© ($)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }

        function updateFeatureList(stats) {
            const featureList = document.getElementById('featureList');
            featureList.innerHTML = '';

            const featureTotals = {};
            stats.forEach(stat => {
                stat.topFeatures.forEach(feature => {
                    if (!featureTotals[feature.feature]) {
                        featureTotals[feature.feature] = { calls: 0, cost: 0 };
                    }
                    featureTotals[feature.feature].calls += feature.calls;
                    featureTotals[feature.feature].cost += feature.cost || 0;
                });
            });

            const sortedFeatures = Object.entries(featureTotals)
                .sort(([,a], [,b]) => b.calls - a.calls)
                .slice(0, 10);

            if (sortedFeatures.length === 0) {
                const li = document.createElement('li');
                li.className = 'feature-item';
                li.innerHTML = '<span class="item-name">Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå</span>';
                featureList.appendChild(li);
                return;
            }

            sortedFeatures.forEach(([feature, stats]) => {
                const li = document.createElement('li');
                li.className = 'feature-item';
                li.innerHTML = `
                    <span class="item-name">${feature}</span>
                    <span class="item-stats">
                        ${stats.calls}Ìöå<br>
                        ${stats.cost.toFixed(4)}
                    </span>
                `;
                featureList.appendChild(li);
            });
        }

        function updateLogsTable(logs) {
            const tbody = document.querySelector('#logsTable tbody');
            tbody.innerHTML = '';

            if (logs.length === 0) {
                const row = tbody.insertRow();
                row.innerHTML = '<td colspan="8" style="text-align: center; color: #999;">Î°úÍ∑∏ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§</td>';
                return;
            }

            logs.forEach(log => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${new Date(log.timestamp).toLocaleString()}</td>
                    <td>${log.provider?.toUpperCase() || 'N/A'}</td>
                    <td>${log.model || 'N/A'}</td>
                    <td>${log.feature || 'N/A'}</td>
                    <td>${(log.totalTokens || 0).toLocaleString()}</td>
                    <td>${(log.cost || 0).toFixed(4)}</td>
                    <td>${log.latency || 0}ms</td>
                    <td>
                        <span class="status-indicator ${log.success ? 'status-success' : 'status-error'}"></span>
                        ${log.success ? 'ÏÑ±Í≥µ' : 'Ïã§Ìå®'}
                    </td>
                `;
            });
        }

        async function exportToCSV() {
            if (!currentData || currentData.length === 0) {
                alert('ÎÇ¥Î≥¥ÎÇº Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.');
                return;
            }

            const headers = ['Í∏∞Í∞Ñ', 'Ìò∏Ï∂úÏàò', 'ÌÜ†ÌÅ∞Ïàò', 'ÎπÑÏö©', 'ÌèâÍ∑†ÏßÄÏó∞ÏãúÍ∞Ñ', 'ÏÑ±Í≥µÎ•†'];
            const rows = currentData.map(stat => [
                stat.period,
                stat.totalCalls,
                stat.totalTokens,
                stat.totalCost.toFixed(4),
                Math.round(stat.avgLatency),
                stat.successRate.toFixed(1)
            ]);

            const csvContent = [headers, ...rows]
                .map(row => row.map(cell => `"${cell}"`).join(','))
                .join('\n');

            downloadFile(csvContent, 'ai-api-usage-stats.csv', 'text/csv');
        }

        async function exportToJSON() {
            if (!allLogs || allLogs.length === 0) {
                alert('ÎÇ¥Î≥¥ÎÇº Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.');
                return;
            }

            const jsonContent = JSON.stringify(allLogs, null, 2);
            downloadFile(jsonContent, 'ai-api-usage-logs.json', 'application/json');
        }

        async function clearIndexedDB() {
            if (!dbManager) {
                alert('IndexedDBÍ∞Ä Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
                return;
            }

            const confirmed = confirm(
                'Ï†ïÎßêÎ°ú Î™®Îì† IndexedDB Îç∞Ïù¥ÌÑ∞Î•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?\n\n' +
                'Ïù¥ ÏûëÏóÖÏùÄ ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏúºÎ©∞, Obsidian ÌîåÎü¨Í∑∏Ïù∏Ïùò Î™®Îì† Î°úÍ∑∏Í∞Ä ÏÇ≠Ï†úÎê©ÎãàÎã§.'
            );

            if (!confirmed) return;

            try {
                await dbManager.clearAllData();
                
                // UI Î¶¨ÏÖã
                allLogs = [];
                currentData = [];
                
                document.getElementById('dashboardContent').style.display = 'none';
                document.getElementById('controls').style.display = 'none';
                
                // Ï∞®Ìä∏ Ï†ïÎ¶¨
                Object.values(charts).forEach(chart => {
                    if (chart) chart.destroy();
                });
                charts = {};
                
                alert('Î™®Îì† Îç∞Ïù¥ÌÑ∞Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.');
                
                // ÌéòÏù¥ÏßÄ ÏÉàÎ°úÍ≥†Ïπ®
                location.reload();
                
            } catch (error) {
                console.error('Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú Ïã§Ìå®:', error);
                alert('Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú Ïã§Ìå®: ' + error.message);
            }
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function showLoading() {
            document.getElementById('loadingIndicator').style.display = 'block';
            document.getElementById('dashboardContent').style.display = 'none';
        }

        function hideLoading() {
            document.getElementById('loadingIndicator').style.display = 'none';
        }

        function showError(message) {
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.innerHTML = `<div class="error">‚ùå ${message.replace(/\n/g, '<br>')}</div>`;
        }

        function hideError() {
            document.getElementById('errorContainer').innerHTML = '';
        }

        // Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú Îç∞Ïù¥ÌÑ∞ ÏÉàÎ°úÍ≥†Ïπ® (5Î∂ÑÎßàÎã§)
        setInterval(() => {
            if (dbManager && allLogs.length > 0) {
                loadIndexedDBData();
            }
        }, 5 * 60 * 1000);
    </script>
</body>
</html>